#!/bin/bash
# Configure rsnapshot in a more advanced and concise way.
#
# See examples/backup.list for an example config.

SCRIPT_SELF="$(readlink -f "$0")"
SCRIPT_ROOT="$(dirname "$SCRIPT_SELF")"


COMMENT_PREFIX='#'
significant_lines() {
	while read -r line; do
		if [ -z "$line" ]; then continue; fi
		if [ "$line" != "${line#$COMMENT_PREFIX}" ]; then continue; fi
		echo "$line"
	done
}

get_section() {
	# $1: regexp to indicate start of section
	# $2: regexp to indicate section name, after start-section regexp
	sed -n -e '/'"$1""$2"'/,/'"$1"'/{
	  s/'"$1""$2"'/\0/;                       tTHEN;
	  :ELSE;x;p;x;${/'"$1"'/!p};              bENDIF;
	  :THEN;$p;
	  :ENDIF;
	  };h;'
	# corner cases all handled :)
}

list_sections() {
	local prefix="$1"
	local matching="${2:-.*}"
	local suffix="${3:-.*}"
	sed -n -e 's/'"$prefix"'\('"$matching"'\)'"$suffix"'/\1/gp'
}

get_backup() {
	local scheme="$1"
	local backup="$2"
	cat "$scheme" \
	  | get_section '^==\s*backup:\s*' "$backup"
}

list_backups() {
	local scheme="$1"
	cat "$scheme" \
	  | list_sections '^==\s*backup:\s*'
}

get_backup_part() {
	local section="$3"
	get_backup "$1" "$2" \
	  | get_section '^--\s*' "$section"
}

list_backup_parts() {
	get_backup "$1" "$2" \
	  | list_sections '^--\s*'
}

find_all() {
	cat
}

find_meta_only() {
	while read -r src key format; do
		key=${key:-2}
		format=${format:-'%s %p'}
		find "$src" -printf "$format"'\n' | sort -k"$key" > "$src.meta"
		echo "$src.meta"
	done
}

find_all_except_gitignore() {
	while read src keep; do
		args=( $keep )
		args=(${args[@]/#/-x\!\'})
		args=(${args[@]/%/\'})
		tmp=$(mktemp --tmpdir rsconf-XXXXXXXX)
		# only exclude .gitignore entries
		# keep locally-ignored stuff as that's probably important
		# also keep stuff matching gitignore patterns in backup.list (negated-ignore in this case, since they are kept)
		# also keep symlinks as they cost next to nothing to store
		find "$src" -xtype d -name .git -execdir sh -c \
		  'git ls-files -oi --directory --exclude-per-directory=.gitignore '"${args[*]}"' |
		  { while read f; do test -h "$f" || echo "$PWD/$f"; done; }' \; > "$tmp"
		echo "$src	exclude_file=$tmp"
	done
}

find_non_dpkg_configs() {
	while read x; do
		find "$x";
	done | sort -u \
	  | comm --nocheck-order -23 \
	      - <(dlocate --filename-only -F '/etc' | grep '^/etc')
	# dlocate has a bug which prevents regexp from working properly
	# see #653279
	# otherwise we would use dlocate '^/etc' instead
}

find_updated_dpkg_configs() {
	debsums -ec
}

find_nonexistent_to_delete() {
	while read src; do
		echo "$src	+rsync_long_args=\"--existing\""
	done
}

make_backup_points() {
	OLDIFS="$IFS"
	IFS="	"
	while read src opts; do
		if [ -n "$opts" ]; then
			echo "backup	$src	$1	$opts";
		else
			echo "backup	$src	$1";
		fi
	done
	IFS="$OLDIFS"
}

generate_conf() {
	local backup_root="$1"
	local scheme="$2"
	local backup="$3"
	cat <<-EOF
	include_conf	$SCRIPT_ROOT/share/rsnapshot.inc
	snapshot_root	$backup_root/$backup

	## Intervals

	sync_first	1
	$(get_backup_part "$scheme" "$backup" RETAIN | tail -n+2)

	## Backup points

	include_conf	\`$SCRIPT_SELF backup_list_points "$backup_root/backup.list" "$backup"\`
	EOF
}

get_scheme_path() {
	echo "$SCRIPT_ROOT/share/${1%.scheme}.scheme"
}

subcmd="$1"
shift

case $subcmd in
scheme_view )
	get_backup "$(get_scheme_path "$1")" "$2"
	;;
scheme_retain )
	get_backup_part "$(get_scheme_path "$1")" "$2" RETAIN | tail -n+2
	;;
scheme_crontab )
	get_backup_part "$(get_scheme_path "$1")" "$2" CRONTAB | tail -n+2
	;;
backup_list_types )
	list_backup_parts "$1" "$2"
	;;
backup_list_points )
	list_backup_parts "$1" "$2" | while read section; do
		get_backup_part "$1" "$2" "$section" \
		  | tail -n+2 | significant_lines \
		  | "find_$section" | make_backup_points "./"
	done
	;;
generate_conf )
	generate_conf "$@"
	;;
install_backup_spec )
	backup_root="$(readlink -f "${1-.}")"
	scheme="$(grep '^scheme: ' "$backup_root/backup.list" | cut '-d ' -f2)"
	scheme="$(get_scheme_path "$scheme")"
	list_backups "$scheme" | while read backup; do
		tee "$backup_root/$backup.conf" <<-EOF
		include_conf	\`$SCRIPT_SELF generate_conf "$backup_root" "$scheme" "$backup"\`
		EOF
	done
	echo "testing configs for validity..."
	list_backups "$scheme" | while read backup; do
		rsnapshot -c "$backup_root/$backup.conf" -q -t sync || exit $?
	done || exit $?
	echo "all configs passed!"
	echo "================================================================"
	echo "File: $backup_root/rsnapshot.crontab"
	echo "----------------------------------------------------------------"
	{
	cat <<-EOF
	# See \`man rsnapshot\` for details
	# The "rsnapshot sync" section is especially useful for these entries

	EOF
	list_backups "$scheme" | while read backup; do
		echo "RS_CONF=$backup_root/$backup.conf"
		get_backup_part "$scheme" "$backup" CRONTAB | tail -n+2
	done
	} | tee "$backup_root/rsnapshot.crontab"
	echo "================================================================"
	read -p "To install this crontab now, copy it into your clipboard then hit Y: [y/N]" x
	if [ "$x" = "y" -o "$x" = "Y" ]; then
		crontab -e
	fi
	;;
test_find_method )
	significant_lines | "find_$1" | make_backup_points "\$BACKUP_TARGET/"
	;;
"")
	cat <<-EOF
	To set up your own backup specification, do:
	1.  customise examples/backup.list
	2.  save it to a BACKUP_ROOT directory of your choice
	3.  'mkdir \$BACKUP_ROOT/\$backup' for each backup in the scheme you chose
	4.  run '$0 install_backup_spec \$BACKUP_ROOT'
	EOF
	;;
*)
	echo >&2 "Usage: $0 <SUBCMD> <ARGS>"
	exit 1
	;;
esac
