#!/bin/bash
# Configure rsnapshot in a more advanced and concise way.
#
# See examples/backup.list for an example config.
# TODO: make sure backup.list is writeable only by the current user

# development directories, override on install
SCRIPT_HOME="$(dirname "$(readlink -f "$0")")"
DATADIR="$SCRIPT_HOME/share"

set -e
abort() { local x="$1"; shift; echo >&2 "rsconf: $@"; exit $x; }

TMPDIR="/tmp"
TMP_PREFIX="default"
set_tmp_prefix() {
	TMP_PREFIX="$(echo "$1" | sha256sum | cut -b1-8)-$2"
}

COMMENT_PREFIX='#'
significant_lines() {
	while read -r line; do
		if [ -z "$line" ]; then continue; fi
		if [ "$line" != "${line#$COMMENT_PREFIX}" ]; then continue; fi
		echo "$line"
	done
}

get_section() {
	# $1: regexp to indicate start of section
	# $2: regexp to indicate section name, after start-section regexp
	sed -n -e '/'"$1""$2"'/,/'"$1"'/{
	  s/'"$1""$2"'/\0/;                       tTHEN;
	  :ELSE;x;p;x;${/'"$1"'/!p};              bENDIF;
	  :THEN;$p;
	  :ENDIF;
	  };h;'
	# corner cases all handled :)
}

list_sections() {
	local prefix="$1"
	local matching="${2:-.*}"
	local suffix="${3:-.*}"
	sed -n -e 's/'"$prefix"'\('"$matching"'\)'"$suffix"'/\1/gp'
}

get_backup() {
	local scheme="$1"
	local backup="$2"
	cat "$scheme" \
	  | get_section '^==\s*backup:\s*' "$backup"
}

list_backups() {
	local scheme="$1"
	cat "$scheme" \
	  | list_sections '^==\s*backup:\s*'
}

get_backup_part() {
	local section="$3"
	get_backup "$1" "$2" \
	  | get_section '^--\s*' "$section" | tail -n+2
}

list_backup_parts() {
	get_backup "$1" "$2" \
	  | list_sections '^--\s*'
}

get_backup_root() {
	test -f "$1/backup.list" || abort 1 "not found: $1/backup.list"
	readlink -f "$1"
}

find_all() {
	cat
}

find_meta_only() {
	OLDIFS="$IFS"
	IFS="	"
	while read -r src key format opts; do
		key=${key:-2}
		format=${format:-'%s %p'}
		find "$src" -printf "$format"'\n' | sort -k"$key" > "$src.meta"
		test -n "$opts" && echo "$src.meta	$opts" || echo "$src.meta"
	done
	IFS="$OLDIFS"
}

find_all_except_gitignore() {
	while read src keep; do
		args=( $keep )
		args=(${args[@]/#/-x\!\'})
		args=(${args[@]/%/\'})
		tmp="$(mktemp --tmpdir="$TMPDIR" "rsconf-${TMP_PREFIX}-XXXXXXXX")"
		# only exclude .gitignore entries
		# keep locally-ignored stuff as that's probably important
		# also keep stuff matching gitignore patterns in backup.list (negated-ignore in this case, since they are kept)
		# also keep symlinks as they cost next to nothing to store
		find "$src" -xtype d -name .git -execdir sh -c \
		  'git ls-files -oi --directory --exclude-per-directory=.gitignore '"${args[*]}"' |
		   { while read f; do test -h "$f" || echo "$PWD/$f"; done; }' \; >> "$tmp"
		find "$src" -xtype d -name .rsconf-git -execdir sh -c \
		  'GIT_DIR=.rsconf-git git ls-files -oi --directory --exclude-per-directory=.rsconf-ignore '"${args[*]}"' |
		   { while read f; do test -h "$f" || echo "$PWD/$f"; done; }' \; >> "$tmp"
		echo "$src	exclude_file=$tmp"
	done
}

find_non_dpkg_configs() {
	while read x; do
		find "$x";
	done | sort -u \
	  | comm --nocheck-order -23 \
	      - <(dlocate --filename-only -F '/etc' | grep '^/etc' | sort -u)
	# dlocate has a bug which prevents regexp from working properly
	# see #653279
	# otherwise we would use dlocate '^/etc' instead
}

find_updated_dpkg_configs() {
	debsums -ec
}

find_nonexistent_to_delete() {
	while read src; do
		echo "$src	+rsync_long_args=--existing"
	done
}

make_backup_points() {
	OLDIFS="$IFS"
	IFS="	"
	while read src opts; do
		test -n "$opts" && echo "backup	$src	$1	$opts" || echo "backup	$src	$1";
	done
	IFS="$OLDIFS"
}

get_scheme_path() {
	echo "$DATADIR/${1%.scheme}.scheme"
}

get_scheme_path_for_root() {
	get_scheme_path "$(grep '^scheme: ' "$1/backup.list" | cut '-d ' -f2)"
}

echo_file_start() {
	echo "================================================================"
	echo "File: $1"
	echo "----------------------------------------------------------------"
}

echo_file_end() {
	echo "================================================================"
}

generate_conf() {
	local backup_root="$1"
	local scheme="$2"
	local backup="$3"
	cat <<-EOF
	## rsconf auto-generated rsnapshot configuration
	## re-generate using \$ "$0" generate_conf "$1" "$2" "$3"

	include_conf	$DATADIR/rsnapshot.inc
	snapshot_root	$backup_root/$backup
	lockfile	$backup_root/$backup/rsnapshot.pid

	## Intervals

	sync_first	1
	$(get_backup_part "$scheme" "$backup" RETAIN | significant_lines | while read level num; do
		echo "retain	$level	$num"
	done)

	## Backup points

	include_conf	\`$0 generate_backup_points "$backup_root" "$backup"\`
	EOF
}

generate_crontab() {
	local backup_root="$1"
	local scheme="$2"
	local header="#0 DO NOT EDIT: AUTOGENERATED RSCONF CRONTAB FOR $backup_root"
	local footer="#1 DO NOT EDIT: AUTOGENERATED RSCONF CRONTAB FOR $backup_root"
	cat <<-EOF
	$header
	# See \`man rsnapshot\` for details
	# The "rsnapshot sync" section is especially useful for these entries
	RSC=$(which "$0")
	RSC_ROOT=$backup_root

	EOF
	list_backups "$scheme" | while read backup; do
		local first=true
		get_backup_part "$scheme" "$backup" CRONTAB | significant_lines | while read level cron; do
			if $first; then
				echo "$cron"'	$RSC run $RSC_ROOT '"$backup sync"' && $RSC run $RSC_ROOT '"$backup $level"
				first=false
			else
				echo "$cron"'	$RSC run $RSC_ROOT '"$backup $level"
			fi
		done
		echo
	done
	cat <<-EOF
	$footer
	EOF
}

install_conf() {
	local backup_root="$(get_backup_root "${1-.}")"
	local scheme="$(get_scheme_path_for_root "$backup_root")"

	# generate configs
	list_backups "$scheme" | while read backup; do
		mkdir -p "$backup_root/$backup"
		echo_file_start "$backup_root/$backup.conf"
		generate_conf "$backup_root" "$scheme" "$backup" | tee "$backup_root/$backup.conf"
	done
	echo_file_end
	echo "testing configs for validity..."
	list_backups "$scheme" | while read backup; do
		rsnapshot -c "$backup_root/$backup.conf" -q -t sync || exit $?
	done || exit $?
	echo "all configs passed!"

	# clean temp files
	list_backups "$scheme" | while read backup; do
		set_tmp_prefix "$backup_root" "$backup"
		rm -f "$TMPDIR/rsconf-$TMP_PREFIX"-*
	done

	# generate crontab
	echo_file_start "$backup_root/rsnapshot.crontab"
	generate_crontab "$backup_root" "$scheme" | tee "$backup_root/rsnapshot.crontab"
	echo_file_end
	local header="#0 DO NOT EDIT: AUTOGENERATED RSCONF CRONTAB FOR $backup_root"
	local footer="#1 DO NOT EDIT: AUTOGENERATED RSCONF CRONTAB FOR $backup_root"
	crontab -l > "./crontab.old"
	crontab -l | sed -e "\	^${header}	{r${backup_root}/rsnapshot.crontab
	h}" -e "\	^${header}	,\	^${footer}	d" -e '${x;s/^$/1/;x;tTHEN;b;:THEN;'"a\

	r${backup_root}/rsnapshot.crontab
	}" | crontab -
	echo "installed $backup_root/rsnapshot.crontab to crontab:"
	echo_file_start '`crontab -l`'
	crontab -l
	echo_file_end
	echo "in case this messed things up, your old crontab is at ./crontab.old"
}

check_status() {
	NAGIOS_HOME="${NAGIOS_HOME:-/usr/lib/nagios}"
	test -d "$NAGIOS_HOME" || abort 1 "NAGIOS_HOME not valid: $NAGIOS_HOME"
	. "$NAGIOS_HOME/plugins/utils.sh"

	local backup_root="$(get_backup_root "${1-.}")"
	local scheme="$(get_scheme_path_for_root "$backup_root")"
	list_backups "$scheme" | while read backup; do
		local syncfile="$backup_root/$backup.sync"
		test -f "$syncfile" || { echo "CRITICAL - never synced: $backup_root/$backup"; exit "$STATE_CRITICAL"; }
		local p_grace="$(expr "$(get_backup_part "$scheme" "$backup" PERIOD)" \* 3 / 2)"
		local p_actual="$(expr "$(date +%s)" - "$(stat -c %Y "$syncfile")")"
		test "$p_actual" -lt "$p_grace" || {
			echo "CRITICAL - not synced: $backup_root/$backup for $p_actual seconds; max allowed $p_grace"
			exit "$STATE_CRITICAL"
		}
	done || exit $?
	echo "OK - all backups up-to-date: $backup_root"
}

generate_backup_points() {
	local backup_root="$(get_backup_root "${1-.}")"
	local backup="$2"
	local backup_list="$backup_root/backup.list"
	set_tmp_prefix "$backup_root" "$backup"
	list_backup_parts "$backup_list" "$backup" | grep -v '^_' | while read section; do
		get_backup_part "$backup_list" "$backup" "$section" | significant_lines \
		  | "find_$section" | make_backup_points "./"
	done
}

run() {
	local backup_root="$(get_backup_root "${1-.}")"
	local backup="$2"
	local backup_list="$backup_root/backup.list"
	local level="$3"
	set_tmp_prefix "$backup_root" "$backup"
	rm -f "$TMPDIR/rsconf-$TMP_PREFIX"-* # rm temp files from last time
	. <(get_backup_part "$backup_list" "$backup" _presync)
	rsnapshot -c "$backup_root/$backup.conf" "$level"
	test "$level" = "sync" && touch "$backup_root/$backup.sync"
	. <(get_backup_part "$backup_list" "$backup" _postsync)
}

subcmd="$1"
shift

case $subcmd in
scheme_view )
	get_backup "$(get_scheme_path "$1")" "$2"
	;;
scheme_* )
	get_backup_part "$(get_scheme_path "$1")" "$2" "$(echo "${subcmd#scheme_}" | tr a-z A-Z)"
	;;
backup_list_types )
	list_backup_parts "$(get_backup_root "${1-.}")/backup.list" "$2" "$3"
	;;
generate_conf | generate_crontab | install_conf | generate_backup_points | run | check_status )
	"$subcmd" "$@"
	;;
test_find_method )
	significant_lines | "find_$1" | make_backup_points "\$BACKUP_TARGET/"
	;;
"")
	cat <<-EOF
	To set up your own backup specification, do:
	1.  customise examples/backup.list, and save it to a BACKUP_ROOT directory of your choice
	2.  run '$0 install_conf \$BACKUP_ROOT'
	EOF
	;;
*)
	echo >&2 "Usage: $0 <SUBCMD> <ARGS>"
	exit 1
	;;
esac
