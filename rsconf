#!/bin/bash
# Configure rsnapshot in a more advanced and concise way.
#
# See examples/backup.list for an example config.

SCRIPT_SELF="$(readlink -f "$0")"
SCRIPT_ROOT="$(dirname "$SCRIPT_SELF")"

LIBDIR="$SCRIPT_HOME/lib"
DATADIR="$SCRIPT_HOME/share"

abort() { local x="$1"; shift; echo >&2 "rsconf: $@"; exit $x; }

COMMENT_PREFIX='#'
significant_lines() {
	while read -r line; do
		if [ -z "$line" ]; then continue; fi
		if [ "$line" != "${line#$COMMENT_PREFIX}" ]; then continue; fi
		echo "$line"
	done
}

get_section() {
	# $1: regexp to indicate start of section
	# $2: regexp to indicate section name, after start-section regexp
	sed -n -e '/'"$1""$2"'/,/'"$1"'/{
	  s/'"$1""$2"'/\0/;                       tTHEN;
	  :ELSE;x;p;x;${/'"$1"'/!p};              bENDIF;
	  :THEN;$p;
	  :ENDIF;
	  };h;'
	# corner cases all handled :)
}

list_sections() {
	local prefix="$1"
	local matching="${2:-.*}"
	local suffix="${3:-.*}"
	sed -n -e 's/'"$prefix"'\('"$matching"'\)'"$suffix"'/\1/gp'
}

get_backup() {
	local scheme="$1"
	local backup="$2"
	cat "$scheme" \
	  | get_section '^==\s*backup:\s*' "$backup"
}

list_backups() {
	local scheme="$1"
	cat "$scheme" \
	  | list_sections '^==\s*backup:\s*'
}

get_backup_part() {
	local section="$3"
	get_backup "$1" "$2" \
	  | get_section '^--\s*' "$section" | tail -n+2
}

list_backup_parts() {
	get_backup "$1" "$2" \
	  | list_sections '^--\s*'
}

get_backup_root() {
	test -f "$1/backup.list" || abort 1 "not found: $1/backup.list"
	readlink -f "$1"
}

find_all() {
	cat
}

find_meta_only() {
	while read -r src key format; do
		key=${key:-2}
		format=${format:-'%s %p'}
		find "$src" -printf "$format"'\n' | sort -k"$key" > "$src.meta"
		echo "$src.meta"
	done
}

find_all_except_gitignore() {
	while read src keep; do
		args=( $keep )
		args=(${args[@]/#/-x\!\'})
		args=(${args[@]/%/\'})
		tmp=$(mktemp --tmpdir rsconf-XXXXXXXX)
		# only exclude .gitignore entries
		# keep locally-ignored stuff as that's probably important
		# also keep stuff matching gitignore patterns in backup.list (negated-ignore in this case, since they are kept)
		# also keep symlinks as they cost next to nothing to store
		find "$src" -xtype d -name .git -execdir sh -c \
		  'git ls-files -oi --directory --exclude-per-directory=.gitignore '"${args[*]}"' |
		  { while read f; do test -h "$f" || echo "$PWD/$f"; done; }' \; > "$tmp"
		echo "$src	exclude_file=$tmp"
	done
}

find_non_dpkg_configs() {
	while read x; do
		find "$x";
	done | sort -u \
	  | comm --nocheck-order -23 \
	      - <(dlocate --filename-only -F '/etc' | grep '^/etc')
	# dlocate has a bug which prevents regexp from working properly
	# see #653279
	# otherwise we would use dlocate '^/etc' instead
}

find_updated_dpkg_configs() {
	debsums -ec
}

find_nonexistent_to_delete() {
	while read src; do
		echo "$src	+rsync_long_args=--existing"
	done
}

make_backup_points() {
	OLDIFS="$IFS"
	IFS="	"
	while read src opts; do
		if [ -n "$opts" ]; then
			echo "backup	$src	$1	$opts";
		else
			echo "backup	$src	$1";
		fi
	done
	IFS="$OLDIFS"
}

get_scheme_path() {
	echo "$DATADIR/${1%.scheme}.scheme"
}

get_scheme_path_for_root() {
	get_scheme_path "$(grep '^scheme: ' "$1/backup.list" | cut '-d ' -f2)"
}

echo_file_start() {
	echo "================================================================"
	echo "File: $1"
	echo "----------------------------------------------------------------"
}

echo_file_end() {
	echo "================================================================"
}

generate_conf() {
	local backup_root="$1"
	local scheme="$2"
	local backup="$3"
	cat <<-EOF
	## rsconf auto-generated rsnapshot configuration
	## re-generate using \$ "$0" generate_conf "$1" "$2" "$3"

	include_conf	$DATADIR/rsnapshot.inc
	snapshot_root	$backup_root/$backup
	lockfile	$backup_root/$backup/rsnapshot.pid

	## Intervals

	sync_first	1
	$(get_backup_part "$scheme" "$backup" RETAIN | significant_lines | while read level num; do
		echo "retain	$level	$num"
	done)

	## Backup points

	include_conf	\`$0 backup_list_points "$backup_root/backup.list" "$backup"\`
	EOF
}

generate_crontab() {
	local backup_root="$1"
	local scheme="$2"
	cat <<-EOF
	# See \`man rsnapshot\` for details
	# The "rsnapshot sync" section is especially useful for these entries
	RS=$(which rsnapshot)

	EOF
	list_backups "$scheme" | while read backup; do
		echo "RS_ROOT=$backup_root/$backup"
		echo "RS_CONF=$backup_root/$backup.conf"
		local first=true
		get_backup_part "$scheme" "$backup" CRONTAB | significant_lines | while read level cron; do
			if $first; then
				echo "$cron"'	$RS -c $RS_CONF sync && /bin/touch $RS_ROOT/lastsync && $RS -c $RS_CONF '"$level"
				first=false
			else
				echo "$cron"'	$RS -c $RS_CONF '"$level"
			fi
		done
		echo
	done
}

install_conf() {
	local backup_root="$(get_backup_root "${1-.}")"
	local scheme="$(get_scheme_path_for_root "$backup_root")"
	list_backups "$scheme" | while read backup; do
		mkdir -p "$backup_root/$backup"
		echo_file_start "$backup_root/$backup.conf"
		generate_conf "$backup_root" "$scheme" "$backup" | tee "$backup_root/$backup.conf"
	done
	echo_file_end
	echo "testing configs for validity..."
	list_backups "$scheme" | while read backup; do
		rsnapshot -c "$backup_root/$backup.conf" -q -t sync || exit $?
	done || exit $?
	echo "all configs passed!"
	echo_file_start "$backup_root/rsnapshot.crontab"
	generate_crontab "$backup_root" "$scheme" | tee "$backup_root/rsnapshot.crontab"
	echo_file_end
	read -p "To install this crontab now, copy it into your clipboard then hit Y: [y/N]" x
	if [ "$x" = "y" -o "$x" = "Y" ]; then
		crontab -e
	fi
}

check_status() {
	NAGIOS_HOME="${NAGIOS_HOME:-/usr/lib/nagios}"
	test -d "$NAGIOS_HOME" || abort 1 "NAGIOS_HOME not valid: $NAGIOS_HOME"
	. "$NAGIOS_HOME/plugins/utils.sh"

	local backup_root="$(get_backup_root "${1-.}")"
	local scheme="$(get_scheme_path_for_root "$backup_root")"
	list_backups "$scheme" | while read backup; do
		local syncfile="$backup_root/$backup/lastsync"
		test -f "$syncfile" || { echo "CRITICAL - never synced: $backup_root/$backup"; exit "$STATE_CRITICAL"; }
		local p_grace="$(expr "$(get_backup_part "$scheme" "$backup" PERIOD)" \* 3 / 2)"
		local p_actual="$(expr "$(date +%s)" - "$(stat -c %Y "$syncfile")")"
		test "$p_actual" -lt "$p_grace" || {
			echo "CRITICAL - not synced: $backup_root/$backup for $p_actual seconds; max allowed $p_grace"
			exit "$STATE_CRITICAL"
		}
	done || exit $?
	echo "OK - all backups up-to-date: $backup_root"
}

subcmd="$1"
shift

case $subcmd in
scheme_view )
	get_backup "$(get_scheme_path "$1")" "$2"
	;;
scheme_* )
	get_backup_part "$(get_scheme_path "$1")" "$2" "$(echo "${subcmd#scheme_}" | tr a-z A-Z)"
	;;
backup_list_types )
	list_backup_parts "$1" "$2"
	;;
backup_list_points )
	list_backup_parts "$1" "$2" | while read section; do
		get_backup_part "$1" "$2" "$section" | significant_lines \
		  | "find_$section" | make_backup_points "./"
	done
	;;
generate_conf | generate_crontab | install_conf | check_status )
	"$subcmd" "$@"
	;;
test_find_method )
	significant_lines | "find_$1" | make_backup_points "\$BACKUP_TARGET/"
	;;
"")
	cat <<-EOF
	To set up your own backup specification, do:
	1.  customise examples/backup.list, and save it to a BACKUP_ROOT directory of your choice
	2.  run '$0 install_conf \$BACKUP_ROOT'
	EOF
	;;
*)
	echo >&2 "Usage: $0 <SUBCMD> <ARGS>"
	exit 1
	;;
esac
