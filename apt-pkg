#!/usr/bin/python2.7

import sys
from pprint import pprint
from collections import namedtuple
from subprocess import Popen, PIPE
from time import time


PKGFILE_MAGIC = "package state"
PKGFILE_DEFAULT = "packages.txt"
PKGFILE_HEADERS = {
	'i': ('manually installed', '~i !(~M)'),
	'r': ('unsatisfied recommends', '~RBrecommends:~i'),
}

ORDER_PRIO = "required important standard optional extra Unknown".split()
ORDER_SECT = """
	kernel admin misc otherosfs fonts
	electronics embedded hamradio comm
	httpd web news mail database
	shells utils net
	kde gnome x11 xfce gnustep localization
	doc libs oldlibs
	editors vcs text
	devel libdevel debug interpreters cli-mono zope
	haskell java lisp ocaml perl php python ruby
	graphics sound video tex
	math science gnu-r
	games
	Unknown
	""".split()

def get_header(hd):
	if hd in PKGFILE_HEADERS: return PKGFILE_HEADERS[hd][0]
	if hd in (hd[1] for hd in PKGFILE_HEADERS.itervalues()): return hd
	raise ValueError("unrecognised header: %s" % hd)

def get_section_order(section):
	try:
		return ORDER_SECT.index(section)
	except ValueError:
		raise ValueError("unrecognised section: %s" % section)

ORDERS = {
	'n': lambda pkg: pkg.name,
	'c': lambda pkg: pkg.status,
	's': lambda pkg: get_section_order(pkg.section_category()),
	'p': lambda pkg: ORDER_PRIO.index(pkg.priority),
}


class PkgSummary(namedtuple("PkgSummary", "status,name,section,priority")):

	def __str__(self):
		return "%s | %s %s | %s" % (
		  self.name, self.section,
		  ORDER_PRIO.index(self.priority), self.status)

	def section_category(self):
		return self.section.split("/")[-1]


def print_err(s):
	print >>sys.stderr, s


def pkgfile_read_section(header, lines):
	sectlines = []
	started = False

	for line in lines:
		if line == "%s:\n" % header:
			started = True
			continue

		if not started: continue
		if not line.rstrip(): break
		sectlines.append(line)

	return sectlines


def pkgfile_parse_lines(lines):
	return (PkgSummary(*line.split()) for line in lines)


def git_detect_repo(fn=PKGFILE_DEFAULT):
	cmdline = "git ls-tree HEAD --".split() + [fn]
	proc = Popen(cmdline, stdout=PIPE)
	stdout, stderr = proc.communicate()
	retcode = proc.wait()
	if stdout:
		return True
	else:
		print_err("git is not tracking %s in the current repo." % fn)
		print_err("if this is a new repo and you intend to use it to track package state, ")
		print_err("please touch that file and commit it, then run this command again.")
		return False


def aptitude_search(pattern, fp):
	cmdline = ["aptitude", "search", "--disable-columns", "-F", "%c %p %s %P",
	           pattern]
	proc = Popen(cmdline, stdout=fp)
	proc.communicate()
	retcode = proc.wait()
	return retcode


def apt_pkg_info(header, sortby='n', fn=PKGFILE_DEFAULT, **extra):
	print "%s:" % header
	with open(fn) as fp:
		lines = fp.readlines()

	pkgs = list(pkgfile_parse_lines(pkgfile_read_section(header, lines)))
	for k in list(sortby).__reversed__():
		pkgs.sort(key=ORDERS[k])

	print "\n".join("%s" % (p,) for p in pkgs),


def apt_pkg_commit(fn=PKGFILE_DEFAULT, **extra):

	if not git_detect_repo(fn): return 1

	with open(fn, 'w') as fp:
		for header, pattern in PKGFILE_HEADERS.itervalues():
			print >>fp, "%s:" % header
			fp.flush()
			aptitude_search(pattern, fp)
			print >>fp, ""
			fp.flush()

	if Popen(["git", "diff", "--quiet"]).wait() == 0:
		print_err("no changes from last time, skipping commit")
		return 0

	# running --exit-code or --quiet skips the pager, so we run it again here
	Popen(["git", "diff"]).wait()
	r = raw_input("commit changes? [n] ")
	if r != "y": return 1
	Popen(["git", "add", fn]).wait()
	Popen(["git", "commit", "-m", "package state at %s" % int(time())]).wait()


def main(subcmd="i", *args, **opts):

	if subcmd == "h" or subcmd == "help":
		print_err("sorry, not implemented yet; in the meantime see --help")
		return 1
	elif subcmd == "i" or subcmd == "info":
		header = PKGFILE_HEADERS['i'][0] if not args else get_header(args[0])
		return apt_pkg_info(header, **opts)
	elif subcmd == "c" or subcmd == "commit":
		return apt_pkg_commit(**opts)
	else:
		raise SyntaxError("unsupported command: %s" % subcmd)


if __name__ == "__main__":
	from argparse import ArgumentParser
	parser = ArgumentParser(description="query or update the apt-pkg file")

	# TODO make separate ArgumentParser for each subcmd, and move subcmd
	# specific options (e.g. -s) there
	parser.add_argument("-f", "--file", dest="fn", default="packages.txt",
	  help="use FILE (default packages.txt)", metavar="FILE")
	parser.add_argument("-s", "--sort", dest="sortby", default="n",
	  help="sort info output by KEYS[0], KEYS[1],... where each char is one "
	  "of [n]ame [c]status [s]ection [p]ackage. nb: section is sorted roughly "
	  "by semantics rather than alphabet; see source code for details",
	  metavar="KEYS")

	parser.add_argument("subcmd",
	  help="one of (info|update) or its firstchar", metavar="CMD")
	parser.add_argument("args", nargs="*",
	  help="see `%(prog)s help CMD' for details", metavar="ARGS")

	opts = parser.parse_args().__dict__
	subcmd = opts.pop("subcmd")
	args = opts.pop("args")

	sys.exit(main(subcmd, *args, **opts))
