#!/usr/bin/python
"""
Store "interesting" aptitude package state under git.

Requires python 2.7.

Use the "init" and "update" subcommands for a demo.
"""
# TODO: make the "diff" subcommand able to take arguments
# TODO: add a subcommand to suggest packages to "markauto"


import sys
from collections import namedtuple
from subprocess import Popen, PIPE, check_call, check_output, CalledProcessError
from time import time

if sys.version_info < (2, 7):
    raise "requires python 2.7"


PKGFILE_MAGIC = "package state"
PKGFILE_DEFAULT = "packages.txt"
PKGFILE_HEADERS = {
	'i': ('manually installed', '~i !(~M)'),
	'r': ('unsatisfied recommends', '~RBrecommends:~i'),
}

ORDER_PRIO = "required important standard optional extra Unknown".split()
ORDER_SECT = """
	kernel admin misc otherosfs fonts
	electronics embedded hamradio comm
	httpd web news mail database
	shells utils net
	kde gnome x11 xfce gnustep localization
	doc libs oldlibs
	editors vcs text
	devel libdevel debug interpreters cli-mono zope
	haskell java lisp ocaml perl php python ruby
	graphics sound video tex
	math science gnu-r
	games
	Unknown
	""".split()

def get_header(hd):
	if hd in PKGFILE_HEADERS: return PKGFILE_HEADERS[hd][0]
	if hd in (hd[1] for hd in PKGFILE_HEADERS.itervalues()): return hd
	raise ValueError("unrecognised header: %s" % hd)

def get_section_order(section):
	try:
		return ORDER_SECT.index(section)
	except ValueError:
		raise ValueError("unrecognised section: %s" % section)

ORDERS = {
	'n': lambda pkg: pkg.name,
	's': lambda pkg: pkg.status,
	'c': lambda pkg: pkg.component, # TODO: main at top
	'e': lambda pkg: get_section_order(pkg.section),
	'p': lambda pkg: ORDER_PRIO.index(pkg.priority),
}


class DiffSpec(namedtuple(
  "DiffSpec", "diff,item")):
	GET_ITEM = lambda d: d.item
	GET_DIFF = lambda d: d.diff

	def __str__(self):
		return self.diff + str(self.item)

	@classmethod
	def FromDiffLine(cls, s):
		return cls(s[0], s[1:])

	@classmethod
	def map(cls, it, f):
		if not it: return []
		diffs, items = zip(*it)
		return map(cls._make, zip(diffs, map(f, items)))


class PkgSummary(namedtuple(
  "PkgSummary", "status,name,component,section,priority")):

	def __str__(self):
		return "%s : %s/%s %s : %s" % (
		  self.name, self.component, self.section,
		  self.priority, self.status)

	@classmethod
	def FromPlainString(cls, s):
		args = s.split()
		if len(args) == 5:
			return cls(*args)
		elif len(args) == 4:
			c, s = PkgSummary.parse_section_string(args[2])
			return cls(args[0], args[1], c, s, args[3])
		else:
			raise ValueError()

	@staticmethod
	def parse_section_string(s, default_cmpt="main"):
		component, sep, section = s.partition("/")
		if not sep: return default_cmpt, component
		else: return component, section


def print_err(s, fp=sys.stderr):
	print >>fp, s


def pkgfile_read_section(header, items, line_ex=lambda x: x):
	sectitems = []
	started = False

	for item in items:
		line = line_ex(item)
		if line == "%s:\n" % header:
			started = True
			continue

		if not started: continue
		if not line.rstrip(): break
		sectitems.append(item)

	return sectitems


def pkgfile_num_lines(fn):
	with open(fn) as fp:
		return len(fp.readlines())


def pkglist_sort(pkgs, sortby, pkg_ex=lambda x: x):
	# assumes sort is stable
	for k in reversed(sortby):
		if k.isupper():
			pkgs.sort(key=lambda x: ORDERS[k.lower()](pkg_ex(x)), reverse=True)
		else:
			pkgs.sort(key=lambda x: ORDERS[k](pkg_ex(x)))


def git_detect_repo(fn):
	stdout = check_output(["git", "ls-tree", "HEAD", "--", fn])
	if stdout: return True
	print_err("git is not tracking %s in the current repo." % fn)
	print_err("if you intend to use this directory to track package state, ")
	print_err("please first run the 'init' subcommand of this program.")
	return False


def aptitude_search(pattern, fp):
	cmdline = ["aptitude", "search", "--disable-columns", "-F", "%c %p %s %P",
	           pattern]
	check_call(cmdline, stdout=fp)


def apt_pkg_init(fn):
	try:
		stdout = check_output("git", "rev-parse", "--show-prefix")
		if not stdout or stdout.strip == ".":
			print_err("abort: already at top-level of existing git repo")
			return 1
		raise ValueError
	except (CalledProcessError, ValueError):
		check_call(["git", "init"])
		open(fn, 'w').close()
		check_call(["git", "add", fn])
		check_call(["git", "commit", "-m", "touch package state"])
		return 0


def apt_pkg_status(fn, header, sortby='n', **extra):
	if not git_detect_repo(fn): return 1

	print "%s:" % header
	with open(fn) as fp:
		pkgs = map(PkgSummary.FromPlainString, pkgfile_read_section(header, fp))

	pkglist_sort(pkgs, sortby)
	print "\n".join(map(str, pkgs)),


def apt_pkg_diff(fn, header, sortby='n', change='+-', **extra):
	num = pkgfile_num_lines(fn)
	proc1 = Popen(["git", "diff", "-U%d" % num, fn], stdout=PIPE)
	proc2 = Popen(["sed", "-e", "1,/^@@/d"], stdout=PIPE, stdin=proc1.stdout)

	items = map(DiffSpec.FromDiffLine, proc2.stdout)
	items = pkgfile_read_section(header, items, DiffSpec.GET_ITEM)
	items = DiffSpec.map(items, PkgSummary.FromPlainString)
	items = filter(lambda d: d.diff in change, items)

	pkglist_sort(items, sortby, DiffSpec.GET_ITEM)
	print "\n".join(map(str, items))


def apt_pkg_commit(fn, **extra):
	if not git_detect_repo(fn): return 1

	with open(fn, 'w') as fp:
		for header, pattern in PKGFILE_HEADERS.itervalues():
			print >>fp, "%s:" % header
			fp.flush()
			aptitude_search(pattern, fp)
			print >>fp, ""
			fp.flush()

	try:
		check_call(["git", "diff", "--quiet"])
		print_err("no changes from last time, skipping commit")
		return 0
	except CalledProcessError:
		# running --exit-code or --quiet skips the pager, so we run it again here
		check_call(["git", "diff"])
		r = raw_input("commit changes? [n] ")
		if r != "y": return 1
		check_call(["git", "add", fn])
		check_call(["git", "commit", "-m", "package state at %s" % int(time())])


def main(subcmd="s", *args, **opts):

	fn = opts.pop("fn", PKGFILE_DEFAULT)

	if subcmd == "h" or subcmd == "help":
		print_err("sorry, not implemented yet; in the meantime see --help")
		return 1
	elif subcmd == "i" or subcmd == "init":
		return apt_pkg_init(fn)
	elif subcmd == "s" or subcmd == "status":
		header = PKGFILE_HEADERS['i'][0] if not args else get_header(args[0])
		return apt_pkg_status(fn, header, **opts)
	elif subcmd == "d" or subcmd == "diff":
		header = PKGFILE_HEADERS['i'][0] if not args else get_header(args[0])
		return apt_pkg_diff(fn, header, **opts)
	elif subcmd == "u" or subcmd == "update":
		return apt_pkg_commit(fn, **opts)
	else:
		raise SyntaxError("unsupported command: %s" % subcmd)


if __name__ == "__main__":
	from argparse import ArgumentParser
	parser = ArgumentParser(description="query or update the state file")

	# TODO make separate ArgumentParser for each subcmd, and move subcmd
	# specific options (e.g. -s) there
	parser.add_argument("-f", "--file",
	  dest="fn", metavar="FILE", default="packages.txt",
	  help="use FILE (default packages.txt)")
	parser.add_argument("-s", "--sort",
	  dest="sortby", metavar="KEYS", default="n",
	  help="sort state output by KEYS[0], KEYS[1],... where each char is one "
	  "of [n]ame [s]tatus [c]ompoment s[e]ction [p]ackage. capitalise the "
	  "char to reverse. NB: section is sorted roughly by semantics, not "
	  "alphabet; see source code for details")
	parser.add_argument("-c", "--change",
	  dest="change", metavar="CHANGE", default="+-",
	  help="filter diff output by type of change: [ ]unchanged, "
	  "[+]insertion [-]deletion, default is +-")

	parser.add_argument("subcmd",
	  help="one of (status|update) or its firstchar", metavar="CMD")
	parser.add_argument("args", nargs="*",
	  help="see `%(prog)s help CMD' for details", metavar="ARGS")

	opts = parser.parse_args().__dict__
	subcmd = opts.pop("subcmd")
	args = opts.pop("args")

	sys.exit(main(subcmd, *args, **opts))
